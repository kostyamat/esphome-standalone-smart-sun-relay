esphome:
  name: sun-relay
  friendly_name: "Sun Relay Controller"
  name_add_mac_suffix: true
  on_boot:
  - priority: -100 # Виконуємо всю логіку в одному блоці для ясності
    then:
      - lambda: |-
          id(relay).turn_on();
          id(g_time_source) = "NONE";
          id(time_source_sensor).publish_state("NONE");
          ESP_LOGI("main", "Boot sequence started. Relay ON (safe mode).");

      # Крок 1: Перевіряємо, чи компонент ds1307 взагалі ініціалізувався.
      - lambda: |-
          if (id(rtc_time).is_failed()) {
            ESP_LOGW("rtc_check", "DS1307 component failed to set up. RTC is not present.");
            id(g_rtc_present) = false;
          } else {
            ESP_LOGI("rtc_check", "DS1307 component initialized successfully. RTC is present.");
            id(g_rtc_present) = true;
          }

      # Крок 2: Якщо RTC присутній, читаємо час і перевіряємо його валідність.
      - if:
          condition:
            lambda: 'return id(g_rtc_present);'
          then:
            - ds1307.read_time:
            - lambda: |-
                if (id(sntp_time).utcnow().year < 2024) {
                  ESP_LOGW("rtc_check", "RTC time is invalid (year < 2024). Ignoring time.");
                } else {
                  ESP_LOGI("rtc_check", "Successfully loaded valid time from RTC.");
                  if (id(g_time_source) != "SNTP") {
                    id(g_time_source) = "RTC";
                    id(time_source_sensor).publish_state("RTC");
                  }
                }
      
      # Крок 3: ПРИМУСОВО встановлюємо UTC для всіх C-бібліотек ПІСЛЯ всіх операцій з часом.
      - lambda: |-
          #include <time.h>
          setenv("TZ", "UTC0", 1);
          tzset();
          ESP_LOGI("main", "C-library timezone has been FORCED to UTC.");

      # Крок 4: Перевірка конфігурації після Factory Reset.
      - lambda: |-
          if (id(is_configured_flag) != true) {
            ESP_LOGW("boot_check", "Device is not configured or was factory reset. Applying default values.");
            id(latitude_value) = 37.2469; 
            id(longitude_value) = -1.8682;
            id(utc_offset) = 2.0;
            id(sunrise_offset_hours) = 0.0;
            id(sunset_offset_hours) = 0.0;
            id(is_configured_flag) = true;
          }

      # Крок 5: Фінальна ініціалізація інтерфейсу та компонентів.
      - lambda: |-
          id(sun_component).set_latitude(id(latitude_value));
          id(sun_component).set_longitude(id(longitude_value));
      - delay: 2s
      - lambda: |-
          auto call1 = id(latitude_text).make_call();
          call1.set_value(to_string(id(latitude_value)));
          call1.perform();
          auto call2 = id(longitude_text).make_call();
          call2.set_value(to_string(id(longitude_value)));
          call2.perform();
          auto call3 = id(utc_offset_number).make_call();
          call3.set_value(id(utc_offset));
          call3.perform();
          auto call4 = id(sunrise_offset).make_call();
          call4.set_value(id(sunrise_offset_hours));
          call4.perform();
          auto call5 = id(sunset_offset).make_call();
          call5.set_value(id(sunset_offset_hours));
          call5.perform();
          id(current_time_sensor).update();
          id(next_sunrise_sensor).update();
          id(next_sunset_sensor).update();
          id(relay_on_time_sensor).update();
          id(relay_off_time_sensor).update();
          id(sun_control_status).update();
          ESP_LOGI("main", "All template components synced with global values");

esp8266:
  board: d1_mini
  restore_from_flash: true

i2c:
  id: i2c_bus
  sda: D2
  scl: D1
  scan: true

wifi:
  power_save_mode: none
  enable_on_boot: true
  reboot_timeout: 0s
  on_connect:
    then:
      - lambda: 'ESP_LOGD("wifi_sync", "Wi-Fi connected. Forcing SNTP time sync.");'
      - component.update: sntp_time
  ap:
    password: "12345678"
    ap_timeout: 10s


logger:

api:
  reboot_timeout: 0s

ota:
  platform: esphome

web_server:
  port: 80
  include_internal: true
  local: true
  version: 3
  sorting_groups:
    - id: time_group
      name: "Time & Sources"
      sorting_weight: 10
    - id: location_group
      name: "Location & Offset"
      sorting_weight: 20
    - id: control_group
      name: "Control"
      sorting_weight: 30
    - id: wifi_group
      name: "WiFi control"
      sorting_weight: 40
    - id: status_group
      name: "Status"
      sorting_weight: 50

time:
  - platform: sntp
    id: sntp_time
    timezone: UTC
    servers:
      - "pool.ntp.org"
      - "time.google.com"
    on_time_sync:
      then:
        - if:
            condition:
              lambda: 'return id(g_rtc_present);'
            then:
              - ds1307.write_time:
                  id: rtc_time
              - lambda: 'ESP_LOGI("time", "Time written to DS1307 RTC.");'
        - lambda: |-
            if (network::is_connected()) {
              id(g_time_source) = "SNTP";
              id(time_source_sensor).publish_state("SNTP");
              ESP_LOGI("time", "SNTP time synchronized.");
            }

  - platform: ds1307
    id: rtc_time

globals:
  - id: latitude_value
    type: float
    initial_value: '37.2469'
    restore_value: true
  - id: longitude_value
    type: float
    initial_value: '-1.8682'
    restore_value: true
  - id: utc_offset
    type: float
    initial_value: '2.0'
    restore_value: true
  - id: sunrise_offset_hours
    type: float
    initial_value: '0.0'
    restore_value: true
  - id: sunset_offset_hours
    type: float
    initial_value: '0.0'
    restore_value: true
  - id: new_ssid
    type: std::string
    restore_value: false
  - id: new_password
    type: std::string
    restore_value: false
  - id: is_configured_flag
    type: bool
    initial_value: 'false'
    restore_value: true
  - id: g_time_source
    type: std::string
    initial_value: '"NONE"'
    restore_value: true
  - id: g_rtc_present
    type: bool
    initial_value: 'false'

text:
  - platform: template
    name: "Latitude"
    id: latitude_text
    mode: text
    optimistic: true
    web_server:
      sorting_group_id: location_group
      sorting_weight: 10
    on_value:
      then:
        - lambda: |-
            float lat = 0.0;
            if (sscanf(x.c_str(), "%f", &lat) == 1) {
              if (lat >= -90.0 && lat <= 90.0) {
                id(latitude_value) = lat;
                id(sun_component).set_latitude(lat);
                id(next_sunrise_sensor).update();
                id(next_sunset_sensor).update();
                id(relay_on_time_sensor).update();
                id(relay_off_time_sensor).update();
                id(sun_control_status).update();
              }
            }

  - platform: template
    name: "Longitude"
    id: longitude_text
    mode: text
    optimistic: true
    web_server:
      sorting_group_id: location_group
      sorting_weight: 20
    on_value:
      then:
        - lambda: |-
            float lon = 0.0;
            if (sscanf(x.c_str(), "%f", &lon) == 1) {
              if (lon >= -180.0 && lon <= 180.0) {
                id(longitude_value) = lon;
                id(sun_component).set_longitude(lon);
                id(next_sunrise_sensor).update();
                id(next_sunset_sensor).update();
                id(relay_on_time_sensor).update();
                id(relay_off_time_sensor).update();
                id(sun_control_status).update();
              }
            }
  
  - platform: template
    name: "New Wi-Fi SSID"
    id: ssid_text_input
    mode: text
    optimistic: true
    initial_value: 'New SSID'
    web_server:
      sorting_group_id: wifi_group
      sorting_weight: 10
    on_value:
      then:
        - lambda: 'id(new_ssid) = x;'

  - platform: template
    name: "New Wi-Fi Password"
    id: password_text_input
    mode: password
    optimistic: true
    web_server:
      sorting_group_id: wifi_group
      sorting_weight: 20
    on_value:
      then:
        - lambda: 'id(new_password) = x;'

  - platform: template
    name: "Set Local Time (YYYY-MM-DD HH:MM)"
    id: manual_datetime_text
    mode: text
    initial_value: '2025-01-01 12:00'
    optimistic: true
    web_server:
      sorting_group_id: time_group
      sorting_weight: 5

number:
  - platform: template
    name: "UTC Offset Hours"
    id: utc_offset_number
    optimistic: true
    min_value: -12
    max_value: 14
    step: 0.5
    web_server:
      sorting_group_id: location_group
      sorting_weight: 30
    on_value:
      then:
        - lambda: |-
            id(utc_offset) = x;
            id(current_time_sensor).update();
            id(next_sunrise_sensor).update();
            id(next_sunset_sensor).update();
            id(relay_on_time_sensor).update();
            id(relay_off_time_sensor).update();

  - platform: template
    name: "Sunrise Offset Hours"
    id: sunrise_offset
    optimistic: true
    min_value: -3
    max_value: 3
    step: 0.5
    web_server:
      sorting_group_id: location_group
      sorting_weight: 40
    on_value:
      then:
        - lambda: |-
            id(sunrise_offset_hours) = x;
            id(relay_off_time_sensor).update();

  - platform: template
    name: "Sunset Offset Hours"
    id: sunset_offset
    optimistic: true
    min_value: -3
    max_value: 3
    step: 0.5
    web_server:
      sorting_group_id: location_group
      sorting_weight: 50
    on_value:
      then:
        - lambda: |-
            id(sunset_offset_hours) = x;
            id(relay_on_time_sensor).update();

switch:
  - platform: gpio
    pin: D5
    name: "Sun Relay"
    id: relay
    restore_mode: RESTORE_DEFAULT_ON
    web_server:
      sorting_group_id: control_group
      sorting_weight: 10

sensor:
  - platform: wifi_signal
    name: "WiFi RSSI"
    id: wifi_rssi
    update_interval: 10s
    web_server:
      sorting_group_id: status_group
      sorting_weight: 10

text_sensor:
  - platform: template
    name: "Current Time"
    id: current_time_sensor
    update_interval: 1s
    web_server:
      sorting_group_id: time_group
      sorting_weight: 10
    lambda: |-
      auto utc_now = id(sntp_time).utcnow();
      if (utc_now.is_valid()) {
        int total_minutes = (utc_now.hour * 60 + utc_now.minute) + (int)(id(utc_offset) * 60);
        
        while (total_minutes >= 1440) total_minutes -= 1440;
        while (total_minutes < 0) total_minutes += 1440;
        
        char str[32];
        snprintf(str, sizeof(str), "%04d-%02d-%02d %02d:%02d:%02d", 
                 utc_now.year, utc_now.month, utc_now.day_of_month,
                 total_minutes / 60, total_minutes % 60, utc_now.second);
        return {str};
      }
      return {"Time unavailable"};

  - platform: template
    name: "Relay State"
    id: relay_state_sensor
    update_interval: 5s
    web_server:
      sorting_group_id: status_group
      sorting_weight: 20
    lambda: |-
      return {id(relay).state ? "ON" : "OFF"};

  - platform: template
    name: "Time Source"
    id: time_source_sensor
    update_interval: never
    web_server:
      sorting_group_id: time_group
      sorting_weight: 20
    lambda: |-
      return id(g_time_source);
      
  - platform: template
    name: "Next Sunrise"
    id: next_sunrise_sensor
    update_interval: 10s
    web_server:
      sorting_group_id: time_group
      sorting_weight: 30
    lambda: |-
      auto sunrise_utc_opt = id(sun_component).sunrise(-0.833);
      if (sunrise_utc_opt.has_value()) {
        ESPTime event_utc = sunrise_utc_opt.value();
        int total_minutes = (event_utc.hour * 60 + event_utc.minute) + (int)(id(utc_offset) * 60);
        
        while (total_minutes >= 1440) total_minutes -= 1440;
        while (total_minutes < 0) total_minutes += 1440;
        
        char buffer[16];
        snprintf(buffer, sizeof(buffer), "%02d:%02d:%02d",
                 total_minutes / 60, total_minutes % 60, event_utc.second);
        return {buffer};
      }
      return {"Unknown"};

  - platform: template
    name: "Next Sunset"
    id: next_sunset_sensor
    update_interval: 10s
    web_server:
      sorting_group_id: time_group
      sorting_weight: 40
    lambda: |-
      auto sunset_utc_opt = id(sun_component).sunset(-0.833);
      if (sunset_utc_opt.has_value()) {
        ESPTime event_utc = sunset_utc_opt.value();
        int total_minutes = (event_utc.hour * 60 + event_utc.minute) + (int)(id(utc_offset) * 60);
        
        while (total_minutes >= 1440) total_minutes -= 1440;
        while (total_minutes < 0) total_minutes += 1440;
        
        char buffer[16];
        snprintf(buffer, sizeof(buffer), "%02d:%02d:%02d",
                 total_minutes / 60, total_minutes % 60, event_utc.second);
        return {buffer};
      }
      return {"Unknown"};

  - platform: template
    name: "Relay ON Time (Today/Tomorrow)"
    id: relay_on_time_sensor
    update_interval: 10s
    web_server:
      sorting_group_id: control_group
      sorting_weight: 50
    lambda: |-
      auto sunset_utc_opt = id(sun_component).sunset(-0.833);
      if (sunset_utc_opt.has_value()) {
        ESPTime event_utc = sunset_utc_opt.value();
        auto now_utc = id(sntp_time).utcnow();
        if (!now_utc.is_valid()) { return {"Time Invalid"}; }

        long event_abs_minutes_utc = (event_utc.day_of_year - 1) * 1440 + event_utc.hour * 60 + event_utc.minute;
        long now_abs_minutes_utc = (now_utc.day_of_year - 1) * 1440 + now_utc.hour * 60 + now_utc.minute;
        long event_abs_minutes_local = event_abs_minutes_utc + (long)((id(utc_offset) + id(sunset_offset_hours)) * 60);
        long now_abs_minutes_local = now_abs_minutes_utc + (long)(id(utc_offset) * 60);
        long event_day_number = event_abs_minutes_local / 1440;
        long now_day_number = now_abs_minutes_local / 1440;

        const char* day_str;
        if (event_day_number == now_day_number) { day_str = "Today";
        } else if (event_day_number > now_day_number) { day_str = "Tomorrow";
        } else { day_str = "Yesterday"; }
        
        int display_minutes_of_day = event_abs_minutes_local % 1440;
        if (display_minutes_of_day < 0) display_minutes_of_day += 1440;

        char buffer[32];
        snprintf(buffer, sizeof(buffer), "%s %02d:%02d:%02d",
                 day_str, display_minutes_of_day / 60, display_minutes_of_day % 60, event_utc.second);
        return {buffer};
      }
      return {"Unknown"};

  - platform: template
    name: "Relay OFF Time (Today/Tomorrow)"
    id: relay_off_time_sensor
    update_interval: 10s
    web_server:
      sorting_group_id: control_group
      sorting_weight: 60
    lambda: |-
      auto sunrise_utc_opt = id(sun_component).sunrise(-0.833);
      if (sunrise_utc_opt.has_value()) {
        ESPTime event_utc = sunrise_utc_opt.value();
        auto now_utc = id(sntp_time).utcnow();
        if (!now_utc.is_valid()) { return {"Time Invalid"}; }

        long event_abs_minutes_utc = (event_utc.day_of_year - 1) * 1440 + event_utc.hour * 60 + event_utc.minute;
        long now_abs_minutes_utc = (now_utc.day_of_year - 1) * 1440 + now_utc.hour * 60 + now_utc.minute;
        long event_abs_minutes_local = event_abs_minutes_utc + (long)((id(utc_offset) + id(sunrise_offset_hours)) * 60);
        long now_abs_minutes_local = now_abs_minutes_utc + (long)(id(utc_offset) * 60);
        long event_day_number = event_abs_minutes_local / 1440;
        long now_day_number = now_abs_minutes_local / 1440;
        
        const char* day_str;
        if (event_day_number == now_day_number) { day_str = "Today";
        } else if (event_day_number > now_day_number) { day_str = "Tomorrow";
        } else { day_str = "Yesterday"; }
        
        int display_minutes_of_day = event_abs_minutes_local % 1440;
        if (display_minutes_of_day < 0) display_minutes_of_day += 1440;

        char buffer[32];
        snprintf(buffer, sizeof(buffer), "%s %02d:%02d:%02d",
                 day_str, display_minutes_of_day / 60, display_minutes_of_day % 60, event_utc.second);
        return {buffer};
      }
      return {"Unknown"};

  - platform: template
    name: "Sun Control Status"
    id: sun_control_status
    update_interval: 60s
    web_server:
      sorting_group_id: control_group
      sorting_weight: 30
    lambda: |-
      auto current_time = id(sntp_time).utcnow();
      if (!current_time.is_valid()) { return {"No time - SAFE MODE (ON)"}; }
      
      auto sunrise_opt = id(sun_component).sunrise(-0.833);
      auto sunset_opt = id(sun_component).sunset(-0.833);
      if (!sunrise_opt.has_value() || !sunset_opt.has_value()) { return {"Sun calc failed - SAFE MODE (ON)"}; }
      
      auto sunrise_time = sunrise_opt.value();
      auto sunset_time = sunset_opt.value();
      int now_seconds = current_time.hour * 3600 + current_time.minute * 60 + current_time.second;
      int sunrise_seconds = sunrise_time.hour * 3600 + sunrise_time.minute * 60 + sunrise_time.second;
      int sunset_seconds = sunset_time.hour * 3600 + sunset_time.minute * 60 + sunset_time.second;
      
      bool is_daytime;
      if (sunrise_seconds < sunset_seconds) {
        is_daytime = (now_seconds >= sunrise_seconds && now_seconds < sunset_seconds);
      } else {
        is_daytime = !(now_seconds >= sunset_seconds && now_seconds < sunrise_seconds);
      }
      
      return {is_daytime ? "DAY - Relay should be OFF" : "NIGHT - Relay should be ON"};

sun:
  id: sun_component
  latitude: 37.2469
  longitude: -1.8682

interval:
  - interval: 10s
    then:
      - lambda: |-
          setenv("TZ", "UTC0", 1);
          tzset();
          ESP_LOGI("rtc_sync", "This is hack! C-library timezone has been periodic re-forced to UTC.");
          auto current_time = id(sntp_time).utcnow();
          if (!current_time.is_valid()) {
            if (!id(relay).state) id(relay).turn_on();
            return;
          }
          
          auto sunrise_opt = id(sun_component).sunrise(-0.833);
          auto sunset_opt = id(sun_component).sunset(-0.833);
          if (!sunrise_opt.has_value() || !sunset_opt.has_value()) {
            if (!id(relay).state) id(relay).turn_on();
            return;
          }
          
          auto sunrise_time = sunrise_opt.value();
          auto sunset_time = sunset_opt.value();
          int now_seconds = current_time.hour * 3600 + current_time.minute * 60 + current_time.second;
          int sunrise_seconds = sunrise_time.hour * 3600 + sunrise_time.minute * 60 + sunrise_time.second;
          int sunset_seconds = sunset_time.hour * 3600 + sunset_time.minute * 60 + sunset_time.second;
          
          bool is_daytime;
          if (sunrise_seconds < sunset_seconds) {
            is_daytime = now_seconds >= sunrise_seconds && now_seconds < sunset_seconds;
          } else {
            is_daytime = !(now_seconds >= sunset_seconds && now_seconds < sunrise_seconds);
          }
          
          bool should_be_on = !is_daytime;
          
          if (should_be_on && !id(relay).state) {
            id(relay).turn_on();
          } else if (!should_be_on && id(relay).state) {
            id(relay).turn_off();
          }


  - interval: 1h 
    then:
      - if:
          condition:
            lambda: 'return !network::is_connected();'
          then:
            - if:
                condition:
                  lambda: 'return id(g_rtc_present);'
                then:
                  - lambda: 'ESP_LOGD("rtc_sync", "No WiFi. Performing hourly sync with RTC.");'
                  - ds1307.read_time:
                  - lambda: |-
                      setenv("TZ", "UTC0", 1);
                      tzset();
                      ESP_LOGI("rtc_sync", "C-library timezone has been re-forced to UTC after RTC read.");
                      id(g_time_source) = "RTC";
                      id(time_source_sensor).publish_state("RTC");

  - interval: 600s 
    then:
      - if:
          condition:
            wifi.connected:
          then:
            - lambda: 'ESP_LOGD("sntp_sync", "Performing periodic SNTP time sync.");'
            - component.update: sntp_time

button:
  - platform: template
    name: "Apply Time"
    web_server:
      sorting_group_id: time_group
      sorting_weight: 8
    on_press:
      then:
        - lambda: |-
            const char *datetime_str = id(manual_datetime_text).state.c_str();
            ESP_LOGD("main", "Attempting to set time from LOCAL string: %s", datetime_str);
            
            struct tm timeinfo;
            if (strptime(datetime_str, "%Y-%m-%d %H:%M", &timeinfo) != nullptr) {
              timeinfo.tm_sec = 0;
              time_t epoch = mktime(&timeinfo);
              
              if (epoch != -1) {
                int offset_seconds = id(utc_offset) * 3600;
                time_t corrected_epoch = epoch - offset_seconds;
                struct timeval tv;
                tv.tv_sec = corrected_epoch;
                tv.tv_usec = 0;
                settimeofday(&tv, nullptr);
                ESP_LOGI("main", "System time updated manually via settimeofday().");
                id(g_time_source) = "Manual";
                id(time_source_sensor).publish_state("Manual");
              } else {
                ESP_LOGE("main", "mktime() failed to convert time!");
                id(g_time_source) = "Manual Set Failed";
                id(time_source_sensor).publish_state(id(g_time_source));
              }
            } else {
              ESP_LOGE("main", "Failed to parse datetime string!");
              id(g_time_source) = "Manual Set Failed";
              id(time_source_sensor).publish_state(id(g_time_source));
            }
        - delay: 100ms
        - if:
            condition:
              lambda: 'return id(g_rtc_present);'
            then:
              - ds1307.write_time:
                  id: rtc_time
              - lambda: 'ESP_LOGI("main", "New time written to DS1307 RTC.");'

  - platform: restart
    name: "Restart Device"
    web_server:
      sorting_group_id: control_group
      sorting_weight: 80

  - platform: template
    name: "Force Update All Sensors"
    web_server:
      sorting_group_id: control_group
      sorting_weight: 70
    on_press:
      then:
        - lambda: |-
            id(current_time_sensor).update();
            id(next_sunrise_sensor).update();
            id(next_sunset_sensor).update();
            id(relay_on_time_sensor).update();
            id(relay_off_time_sensor).update();
            id(sun_control_status).update();

  - platform: template
    name: "Save and connect to new Wifi"
    web_server:
      sorting_group_id: wifi_group
      sorting_weight: 30
    on_press:
      then:
        - wifi.configure:
            ssid: !lambda 'return id(new_ssid);'
            password: !lambda 'return id(new_password);'
            save: true
            timeout: 30s
        - delay: 1s

  - platform: factory_reset
    name: "Factory Reset"
    web_server:
      sorting_group_id: control_group
      sorting_weight: 90

http_request:
  useragent: esphome/device
  timeout: 10s
  verify_ssl: false